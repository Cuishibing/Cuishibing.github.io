二叉树的遍历方法基本分为：
- 深度优先
- 广度优先

其中深度优先根据根节点处理顺序的不同分为:
- 前序遍历
- 中序遍历
- 后序遍历
----
## 前序遍历
根节点在子节点之前被处理，使用递归方法很容易，下面记录一下非递归方法。
**递归方法都能改写为非递归方法（有时候是很难的），使用递归方法时是由编译器来处理栈的参数，改写后就是我们手动处理栈相关的操作。**
非递归代码:
<!-- more -->
````java
public List<TreeNode> preOrderTraverse(TreeNode root) {
    List<TreeNode> traverse = new ArrayList<>();

    Deque<TreeNode> stack = new LinkedList<>();
    TreeNode curNode = root;
    while (curNode != null) {
        // 先处理根节点（这里curNode就是根节点）
        traverse.add(curNode);
        stack.offerLast(curNode);

        // 这里其实是处理根节点的左节点
        curNode = curNode.left;

        while (curNode == null && stack.size() != 0) {
            TreeNode node = stack.pollLast();
            if (node.right != null) {
                // 处理右节点
                curNode = node.right;
            }
        }
    }
    return traverse;
}
````
看起来更直观的写法：
````java
public List<TreeNode> preOrderTraverse(TreeNode root) {
    List<TreeNode> traverse = new ArrayList<>();

    Deque<TreeNode> stack = new LinkedList<>();
    stack.offerLast(root);
    while (stack.size() != 0) {
        TreeNode node = stack.pollLast();
        traverse.add(node);

        if (node.right != null) {
            stack.offerLast(node.right);
        }
        if (node.left != null) {
            stack.offerLast(node.left);
        }
    }

    return traverse;
}
````
## 中序遍历
根节点在子节点之间被处理
非递归代码：
````java
public List<TreeNode> middleOrderTraverse(TreeNode root) {
    List<TreeNode> traverse = new ArrayList<>();

    Deque<TreeNode> stack = new LinkedList<>();
    TreeNode curNode = root;
    while (curNode != null) {
        stack.offerLast(curNode);
        // 处理左节点
        curNode = curNode.left;
        while (curNode == null && stack.size() != 0) {
            TreeNode node = stack.pollLast();
            // 处理根节点
            traverse.add(node);

            if (node.right != null) {
                // 处理右节点
                curNode = node.right;
            }
        }

    }
    return traverse;
}
````
## 后序遍历
根节点在子节点之后被处理
非递归代码：
````java
public List<TreeNode> postOrderTraverse(TreeNode root) {
    TreeNode lastVisitNode = null;

    List<TreeNode> traverse = new ArrayList<>();
    Deque<TreeNode> stack = new LinkedList<>();
    TreeNode curNode = root;
    while (curNode != null) {
        stack.offerLast(curNode);
        // 处理左节点
        curNode = curNode.left;
        while (curNode == null && stack.size() != 0) {
            TreeNode node = stack.peekLast();
            
            /**
            后序遍历时栈回退时需要知道节点是否已经被处理过，这里用一个遍历记录最后一次访问的节点
            当node.right == lastVisitNode时说明该节点的左右节点都已经被访问过，此时应该访问该节点
            */
            if (node.right != null && node.right != lastVisitNode) {
                // 处理右节点
                curNode = node.right;
            } else {
                lastVisitNode = stack.pollLast();
                // 根节点
                traverse.add(lastVisitNode);
            }
        }
    }
    return traverse;
}
````
## 总结
前中后三种遍历方法的代码结构是一样的（不包括前序的第二种写法），在处理根节点的访问时存在不同。